<dom-module id="tmp-map">
	<!--COPYRIGHT 2015 Sebastian Schneider & Dennis Kugelmann, all rights reserved -->
	<template>
		<style>
		section {
			height: 100%;
			width: 100%;
			background-color: #EEEEEE;
			margin: auto;
		}

		map {
			height: 100%;
			width: 100%;
			position: absolute;
		}
		.border {
			box-sizing: border-box;
			position: absolute;
			/*debug*/
			padding: 10px 0 0 10px;
			/*border: 1px dotted #555; /*debug*/
		}
		.btop{
			border-top: 5px solid black;
		}
		.bright{
			border-right: 4px solid black;
		}
		.bbottom{
			border-bottom: 4px solid black;
		}
		.bleft{
			border-left: 4px solid black;
		}
		.red{
			background-color: red;
		}
		</style>
		<section>
			<map id="map"></map>
		</section>
	</template>
	<script src="../../js/main.js"></script>
	<script type="text/javascript">
		Polymer({
			is: 'tmp-map',

			attached: function(){
				generateMap();
				mapTo_16_9();
				runLabAlgor();
				drawMap();
			}
		});

		var blocks = [];

		function runLabAlgor(){
			//pick random start at border
			var curBl = "";
			var x = blocks.length;
			var y = blocks[0].length;
			var cx = getRandomInt(0, x - 1);
			var cy = getRandomInt(0, y - 1);
			var run = true;
			var count = 0;

			while(run){
				var newB = newBlock(x, y, cx, cy);

				//$("#border" + newB["x"] + "_" + newB["y"]).addClass("red");

				cx = newB["x"];
				cy = newB["y"];

				if(count == x * y * 35){run = false;} //average value
				count++;
			}

			debugFields();

			//Map ready call
			var event = new Event('map-ready');
			
		}
		function debugFields(){
			var counter = 0;

			for(var r = 1; r < 4; r++){
				for(var i = 0; i < blocks.length; i++){
					for(var j = 0; j < blocks[i].length; j++){

						//define elements & anti 2x2 fields
						if(r == 1){
							if(!blocks[i][j][4]){
								blocks[i][j][0] = blocks[i - 1][j][0];
							}
							else{
								blocks[i][j][0] = counter;
								counter++;
							}
							
							//anti 2x2

							if(i + 1 < blocks.length && j + 1 < blocks[i].length){
								if(!blocks[i + 1][j][4] && !blocks[i + 1][j + 1][1] && !blocks[i + 1][j + 1][4] && !blocks[i][j + 1][1]){
									blocks[i + 1][j + 1][1] = true;
								}
							}

						}
						//search for related blocks of border elements and give them the same count
						else if(r == 2){
							if(j != 0){ //if no topelement
								if(!blocks[i][j][1]){
									debugRefactor(blocks[i][j][0], blocks[i][j - 1][0]);
								}
							}
						}
						//merge different counts
						else if(r == 3){
							var topelement = (j == 0);
							var leftelement = (i == 0);
							var botelement = (j + 1 >= blocks.length);
							var rightelement = (i + 1 >= blocks[i].length);

							if(j != 0){ //no top element
								if(blocks[i][j][0] != blocks[i][j - 1][0]){
									blocks[i][j][1] = false;
									debugRefactor(blocks[i][j][0], blocks[i][j - 1][0]);
								}
							}
						}						
					}
				}
			}

		}
		function debugRefactor(iscount, refcount){
			for(var i = 0; i < blocks.length; i++){
				for(var j = 0; j < blocks[i].length; j++){
					if(blocks[i][j][0] == refcount){
						blocks[i][j][0] = iscount;
						//debug
						//$("#border" + i + "_" + j).html(blocks[i][j][0]);
					}
				}
			} 
		}
		function drawMap(json){
			var mpblocks = ((json == undefined) ? blocks : JSON.parse(json));

			for(var i = 0; i < mpblocks.length; i++){
				for(var j = 0; j < mpblocks[i].length; j++){
					var bl = mpblocks[i][j];

					if(bl[1]){
						$("#border" + i + "_" + j).addClass("btop");
					}
					if(bl[4]){
						$("#border" + i + "_" + j).addClass("bleft");
					}
				}
			}
		}
		function generateMap(bh){
			var blockHori = ((bh == undefined) ? getRandomInt(8, 25) : bh);
			var blockVerti = parseInt((blockHori / 16) * 9); //16 : 9
			var borderStr = 4;

			var posx = 0;
			var posy = 0;
			var hx = 100 / blockHori
			var hy = 100 / blockVerti;
			var mgtop = 0;
			var mgleft = 0;

			var mapc = "";
			
				for(var i = 0; i < blockHori; i++){
				    blocks[i] = [];
				    for(var j = 0; j < blockVerti; j++){
				    	mapc += "" 
				    	+ "<div id='border" + i + "_" + j +"' style='height: " + hy 
				    	+ "%; width: " + hx
				    	+ "%; top: calc(" + posy 
				    	+ "% + " + ((blockVerti * borderStr) / 2 - 5) + "px); left: calc(" + posx 
				    	+ "% + " + ((blockHori * borderStr) / 2) + "px); margin-top: -" + mgtop
				    	+ "px; margin-left: -" + mgleft
				    	+ "px;' class='tmp-map border ";
				       	
				    	blocks[i][j] = [];

				        blocks[i][j][0] = null;
				        blocks[i][j][1] = false;
				        blocks[i][j][2] = false;
				        blocks[i][j][3] = false;
				        blocks[i][j][4] = false;


				        if(j == 0){
				        	mapc += "btop ";
				        	blocks[i][j][1] = true;
				        } 
				        if(i == blockHori - 1){
				        	mapc += "bright ";
				        	blocks[i][j][2] = true;
				        }
				        if(j == blockVerti - 1){
				        	mapc += "bbottom ";
				        	blocks[i][j][3] = true;
				        }
				        if(i == 0){
				        	mapc += "bleft ";
				        	blocks[i][j][4] = true;
				        }
				        mapc += "'></div>"
				        posy = posy + 100 / blockVerti;
				        mgtop = mgtop + borderStr;
				    }
				    posy = 0;
				    mgtop = 0;
				    mgleft = mgleft + borderStr;
				    posx = posx + 100 / blockHori;
				}

				$("map").html(mapc);
		}
		function mapTo_16_9(){
			if(((window.innerWidth / 16) * 9) < window.outerHeight){
				$("map").height(((window.innerWidth / 16 ) * 9));
				$("map").css("top", (window.outerHeight - ((window.innerWidth / 16) * 9)) / 3); 
			}
			if(((window.outerHeight / 9) * 16) < window.innerWidth){
				$("map").width(((window.outerHeight / 9 ) * 16));
				$("map").css("left", (window.innerWidth - ((window.outerHeight / 9) * 16)) / 2);
			}
		}
		function newBlock(x, y, cx, cy){
			var returner = [];
			var ny = cy;
			var nx = cx;
			var type = getRandomInt(0, 3);

			switch(type){
				case 0: ny = cy - 1; break; //top
				case 1: nx = cx + 1; break; //right
				case 2: ny = cy + 1; break; //bot
				case 3: nx = cx - 1; break; //left
			}

			if(nx < 0 || nx >= x || ny < 0 || ny >= y){
				return newBlock(x, y, cx, cy);
			}
			else{
				switch(type){
					case 0:
						blocks[cx][cy][1] = false;
						if(border(nx, ny, x, y, 1)){
							switch(getRandomInt(0, 2)){
								case 0: blocks[nx][ny][1] = true; break;
								case 1: blocks[nx][ny][4] = true; break;
								case 2: if(nx + 1 < x){blocks[nx + 1][ny][4] = true;} break;
							}
						}						
						break; //top
					case 1: 
						blocks[cx + 1][cy][4] = false;
						if(border(nx, ny, x, y, 1)){
							switch(getRandomInt(0, 2)){
								case 0: blocks[nx][ny][1] = true; break;
								case 1:	if(nx + 1 < x){blocks[nx + 1][ny][4] = true;} break;
								case 2: if(ny + 1 < y){blocks[nx][ny + 1][1] = true;} break;
							}
						}				
						break; //right
					case 2: 
						blocks[cx][cy + 1][1] = false;
						if(border(nx, ny, x, y, 1)){
							switch(getRandomInt(0, 2)){
								case 0: blocks[nx][ny][4] = true; break;
								case 1: if(ny + 1 < y){blocks[nx][ny + 1][1] = true;}break;
								case 2: if(nx + 1 < x){blocks[nx + 1][ny][4] = true;} break;
							}
						}
						break; //bot
					case 3:
						blocks[cx][cy][4] = false;
						if(border(nx, ny, x, y, 1)){
							switch(getRandomInt(0, 2)){
								case 0: blocks[nx][ny][1] = true; break;
								case 1: blocks[nx][ny][4] = true; break;
								case 2: if(ny + 1 < y){blocks[nx][ny + 1][1] = true;} break;
							}
						}		
						break; //left
				}

				returner["x"] = nx;
				returner["y"] = ny;
				return returner;
			}
		}
		function border(nx, ny, bx, by, bed){
			if(countborders(nx, ny, bx, by) <= bed){
						return true;
			}
			else{
				return false;			
			}			
		}
		function countborders(x, y, bx, by){
			var returner = 0;
			var xborder = (x + 1 == bx);
			var yborder = (y + 1 == by);

			if(blocks[x][y][1]){
				returner++;
			}

			if(blocks[x][y][4]){
				returner++;
			}

			if(!xborder){
				if(blocks[x + 1][y][4]){
					returner++;
				}
			}
			else{
				returner++;
			}

			if(!yborder){
				if(blocks[x][y + 1][1]){
					returner++;
				}
			}
			else{
				returner++;
			}
			return returner;
		}
	</script>
</dom-module>  